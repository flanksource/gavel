package models

import (
	"fmt"
	"strings"
	"time"

	"github.com/flanksource/clicky"
	"github.com/flanksource/clicky/api"
	"github.com/flanksource/commons/collections"
	"github.com/flanksource/gavel/models/kubernetes"
	"github.com/samber/lo"
)

type Author struct {
	Name     string    `json:"name,omitempty"`
	Email    string    `json:"email,omitempty"`
	Date     time.Time `json:"date,omitempty"`
	GithubID string    `json:"github_id,omitempty"`
}

func (author Author) Pretty() api.Text {
	t := api.Text{}.Append(author.Name, "font-bold").
		Append(" <"+author.Email+"> ", "text-muted").
		Append(author.Date, "text-muted")
	return t
}

func (a Author) Matches(filter string) bool {
	if filter == "" {
		return true
	}

	if !strings.ContainsAny(filter, "!*,") {
		return strings.Contains(a.Name, filter) || strings.Contains(a.Email, filter)
	}

	matched, negated := collections.MatchItem(a.Name, filter)
	if matched {
		return true
	}
	if negated {
		return false
	}
	matched, negated = collections.MatchItem(a.Email, filter)
	return matched
}

type Commits []Commit

func (c Commits) Pretty() api.Text {
	t := clicky.Text("")
	for i, commit := range c {
		if i > 0 {
			t = t.NewLine()
		}
		t = t.Add(commit.Pretty())
	}
	return t
}

// Commit represents a git commit with relevant metadata
type Commit struct {
	Hash         string            `json:"hash,omitempty" pretty:"style=max-w-[8ch] truncate text-red-600"`
	Repository   string            `json:"repository,omitempty"`
	Author       Author            `json:"author,omitempty"`
	Committer    Author            `json:"committer,omitempty"`
	Headers      map[string]string `json:"headers,omitempty" pretty:"hide"`
	QualityScore int               `json:"score,omitempty" pretty:"label=Quality Score"`
	// First line of commit message
	Subject string `json:"subject,omitempty"`
	// Everything after the first line of the commit message
	Body  string `json:"body,omitempty"`
	Patch string `json:"patch,omitempty" pretty:"hide"`
	// e.g. Signed-off-by, Co-authored-by
	Trailers map[string]string `json:"trailers,omitempty" pretty:"hide"`
	// Any #references found in the subject
	Reference string `json:"reference,omitempty" pretty:"hide"`

	// Conventional commits
	CommitType CommitType `json:"commit_type,omitempty" pretty:"label=Type"`
	Scope      ScopeType  `json:"scope,omitempty" pretty:"label=Scope"`
	// e.g [SKIPCI] [AUTOGENERATED] added as prefixes or suffixes
	Tags []string `json:"tags,omitempty" pretty:"hide"`
}

func (c Commit) Pretty() api.Text {
	t := clicky.Text("")
	t = t.Append("commit ", "text-orange-500").Append(c.Hash).NewLine()
	t = t.Append(clicky.Text("Date: ", "text-muted")).Append(c.Author.Date).NewLine().
		Append("Author: ", "text-muted").Append(c.Author.Name).NewLine()

	if c.Committer.Name != "" && c.Committer.Name != c.Author.Name {
		t = t.Append("Committer: ", "text-muted").Append(c.Committer).NewLine()
	}
	t = t.Append(c.PrettySubject()).NewLine()

	for k, v := range c.Trailers {
		t = t.Append(k+": ", "text-muted").Append(v).NewLine()
	}
	for _, tag := range c.Tags {
		t = t.Append(clicky.Badge(tag, "text-sm text-gray-600 bg-gray-200 mr-1")).Space()
	}
	if len(c.Tags) > 0 {
		t = t.NewLine()
	}

	t = t.Append(c.Body).NewLine()

	return t
}

// FilePatch represents the patch for a single file in a multi-file commit
type FilePatch struct {
	OldPath   string // Path in old version (a/ prefix removed)
	NewPath   string // Path in new version (b/ prefix removed)
	IsNew     bool   // New file creation
	IsDeleted bool   // File deletion
	Patch     string // The unified diff text for this file only
}

// parsePatch splits a multi-file commit patch into individual file patches
func (c *Commit) parsePatch() []FilePatch {
	var patches []FilePatch
	lines := strings.Split(c.Patch, "\n")

	var currentPatch *FilePatch
	var patchLines []string

	for _, line := range lines {
		if strings.HasPrefix(line, "diff --git ") {
			// Save previous patch if exists
			if currentPatch != nil {
				currentPatch.Patch = strings.Join(patchLines, "\n")
				patches = append(patches, *currentPatch)
			}

			// Start new patch
			currentPatch = &FilePatch{}
			patchLines = []string{line}

			// Parse paths: diff --git a/oldpath b/newpath
			parts := strings.Fields(line)
			if len(parts) >= 4 {
				currentPatch.OldPath = strings.TrimPrefix(parts[2], "a/")
				currentPatch.NewPath = strings.TrimPrefix(parts[3], "b/")
			}
		} else if currentPatch != nil {
			patchLines = append(patchLines, line)

			if strings.Contains(line, "new file mode") {
				currentPatch.IsNew = true
			} else if strings.Contains(line, "deleted file mode") {
				currentPatch.IsDeleted = true
			}
		}
	}

	// Save last patch
	if currentPatch != nil {
		currentPatch.Patch = strings.Join(patchLines, "\n")
		patches = append(patches, *currentPatch)
	}

	return patches
}

// GetFilePatch returns the patch for a specific file
func (c *Commit) GetFilePatch(filePath string) string {
	patches := c.parsePatch()
	for _, p := range patches {
		if p.NewPath == filePath || p.OldPath == filePath {
			return p.Patch
		}
	}
	return ""
}

type CommitAnalysis struct {
	Commit  `json:",inline"`
	Tech    []ScopeTechnology `json:"tech,omitempty"`
	Changes Changes           `json:"changes,omitempty"`
	// Original commit before analysis
	Original Commit `json:"-"`
	// Pre-computed metrics for performance
	TotalLineChanges   int `json:"-"`
	TotalResourceCount int `json:"-"`
}

func (ca CommitAnalysis) GetScopes() Scopes {
	scopesSet := make(map[ScopeType]struct{})
	for _, change := range ca.Changes {
		for _, scope := range change.Scope {
			scopesSet[scope] = struct{}{}
		}
	}
	return lo.Keys(scopesSet)
}

func (ca CommitAnalysis) IsAnalyzed() bool {
	if ca.Original.Hash == "" {
		return false
	}
	return ca.Scope != ca.Original.Scope ||
		ca.CommitType != ca.Original.CommitType ||
		ca.Body != ca.Original.Body ||
		ca.Subject != ca.Original.Subject
}

type CommitAnalyses []CommitAnalysis

func (ca CommitAnalyses) Pretty() api.Text {
	t := clicky.Text("")
	for i, analysis := range ca {
		if i > 0 {
			t = t.NewLine()
		}
		t = t.Add(analysis.Pretty())
	}
	return t
}

func (ca CommitAnalyses) From() time.Time {
	if len(ca) == 0 {
		return time.Time{}
	}
	earliest := ca[0].Author.Date
	for _, analysis := range ca {
		if analysis.Author.Date.Before(earliest) {
			earliest = analysis.Author.Date
		}
	}
	return earliest
}

func (ca CommitAnalyses) To() time.Time {
	if len(ca) == 0 {
		return time.Time{}
	}
	latest := ca[0].Author.Date
	for _, analysis := range ca {
		if analysis.Author.Date.After(latest) {
			latest = analysis.Author.Date
		}
	}
	return latest
}

type Changes []CommitChange

func (c Changes) Summary() CommitChange {
	if len(c) == 1 {
		return c[0]
	}
	summary := CommitChange{}
	scopes := make(map[ScopeType]struct{})
	types := make(map[SourceChangeType]struct{})
	techs := make(map[ScopeTechnology]struct{})
	for _, change := range c {
		summary.Adds += change.Adds
		summary.Dels += change.Dels
		for _, scope := range change.Scope {
			scopes[scope] = struct{}{}
		}
		types[change.Type] = struct{}{}
		for _, t := range change.Tech {
			techs[t] = struct{}{}
		}
	}

	summary.Scope = lo.Keys(scopes)

	if len(types) == 1 {
		summary.Type = lo.Keys(types)[0]
	}
	if len(techs) > 0 {
		summary.Tech = lo.Keys(techs)
	}

	return summary
}

func (c Changes) PrettyShort() api.Text {
	return c.Summary().Pretty()
}

func (c Changes) Pretty() api.Text {
	t := clicky.Text("")
	for i, change := range c {
		if i > 0 {
			t = t.NewLine()
		}
		t = t.Add(change.Pretty())
	}
	return t
}

type AIAnalysisOutput struct {
	Type    CommitType `yaml:"type,omitempty" json:"type,omitempty"`
	Scope   ScopeType  `yaml:"scope,omitempty" json:"scope,omitempty"`
	Subject string     `yaml:"subject,omitempty" json:"subject,omitempty"`
	Body    string     `yaml:"body,omitempty" json:"body,omitempty"`
}

func (a AIAnalysisOutput) Pretty() api.Text {
	t := clicky.Text("AI Analysis:", "font-bold").Space().Space()
	t = t.Append("Type: ", "text-muted").Append(string(a.Type)).Space()
	t = t.Append("Scope: ", "text-muted").Append(string(a.Scope)).NewLine()
	t = t.Append(a.Subject).NewLine()
	t = t.NewLine().Append(a.Body, "text-muted")

	return t
}

func (a AIAnalysisOutput) String() string {
	s := ""
	s += string(a.Type)
	if a.Scope != "" {
		s += fmt.Sprintf("(%s)", a.Scope)
	}
	s += ": " + a.Subject
	if a.Body != "" {
		s += "\n" + a.Body
	}
	return s
}

func (ca Commit) AsMap() map[string]any {
	return map[string]any{
		"hash":         ca.Hash,
		"date":         ca.Author.Date,
		"author":       ca.Author.Name,
		"author.email": ca.Author.Email,
		"subject":      ca.Subject,
		"body":         ca.Body,
		"commit_type":  ca.CommitType,
		"scope":        ca.Scope,
		"patch":        ca.Patch,
	}

}

func (ca CommitAnalysis) AsMap() map[string]any {
	m := ca.Commit.AsMap()
	m["scope"] = ca.Scope
	m["commit_type"] = ca.CommitType
	m["tech"] = ca.Tech
	m["changes"] = ca.Changes
	return m
}

func (ca CommitAnalysis) PrettyShort() api.Text {
	return clicky.Text(ca.Hash[:8], "text-muted").Space().
		Append(time.Since(ca.Author.Date), "text-muted").Space().
		Append(ca.Author.Name, "font-bold").Space().
		Append(ca.PrettySubject())

}

func (ca CommitAnalysis) Pretty() api.Text {
	t := ca.Commit.Pretty().NewLine()

	for _, change := range ca.Changes {
		t = t.NewLine().Add(change.Pretty())
	}
	t = t.HR()

	return t
}

func (c Commit) PrettyShort() api.Text {
	return clicky.Text(c.Hash[:8], "text-muted").Space().
		Append(time.Since(c.Author.Date), "text-muted").Space().
		Append(c.Author.Name, "font-bold").Space().
		Append(c.PrettySubject(), "max-w-[60ch] truncate")
}

func (c Commit) PrettySubject() api.Text {
	t := clicky.Text("")
	if c.CommitType != CommitTypeUnknown {
		t = t.Append(c.CommitType.Pretty()).Space().Append(string(c.CommitType))
	}

	if c.Scope != ScopeTypeUnknown {
		t = t.Append("(", "text-muted").Append(string(c.Scope)).Append(")", "text-muted")
	}

	if c.CommitType != CommitTypeUnknown || c.Scope != ScopeTypeUnknown {
		t = t.Append(": ", "text-muted")
	}

	t = t.Append(c.Subject)
	if c.Reference != "" {
		t = t.Space().Append("#").Append(c.Reference, "text-muted").Space()
	}
	return t
}

func (c Commit) PrettyBody() api.Text {
	return clicky.Text(c.Body, "text-muted, max-lines-[3]")
}

func (c CommitAnalysis) PrettyRow2(_ interface{}) map[string]api.Text {
	body := c.PrettySubject()
	changes := c.Changes.Pretty()
	if changes.String() != "" {
		body = body.NewLine().Add(changes)
	}

	return map[string]api.Text{
		"Hash":   clicky.Text(c.Hash[:8], "font-mono order-1"),
		"Date":   clicky.Text("", "order-2").Append(c.Author.Date),
		"Author": clicky.Text(c.Author.Name, "order-3"),
		// "Scopes": clicky.Text("", "order-6").Add(clicky.CompactList(c.GetScopes())),
		// "Type":   clicky.Text(string(c.CommitType), "order-7"),
		"Body": body.Styles("order-4"),
	}
}

type SourceChangeType string

const (
	SourceChangeTypeAdded      SourceChangeType = "added"
	SourceChangeTypeModified   SourceChangeType = "modified"
	SourceChangeTypeDeleted    SourceChangeType = "deleted"
	SourceChangeTypeRenamed    SourceChangeType = "renamed"
	SourceChangeTypeDocumented SourceChangeType = "documented"
	SourceChangeTypeTested     SourceChangeType = "tested"
	SourceChangeTypeRefactored SourceChangeType = "refactored"
	SourceChangeTypeConfigured SourceChangeType = "configured"
	SourceChangeTypeOptimized  SourceChangeType = "optimized"
	SourceChangeTypeFixed      SourceChangeType = "fixed"
	SourceChangeTypeUpgraded   SourceChangeType = "upgraded"
	SourceChangeTypeScaled     SourceChangeType = "scaled"
)

// LineRanges represents a set of line numbers compressed into range format
// e.g., "1-5,7-9,12" represents lines 1,2,3,4,5,7,8,9,12
type LineRanges string

// NewLineRanges creates a LineRanges from a slice of line numbers
// Lines are sorted and contiguous sequences are compressed into ranges
func NewLineRanges(lines []int) LineRanges {
	if len(lines) == 0 {
		return ""
	}

	// Sort lines
	sorted := make([]int, len(lines))
	copy(sorted, lines)
	for i := 0; i < len(sorted); i++ {
		for j := i + 1; j < len(sorted); j++ {
			if sorted[i] > sorted[j] {
				sorted[i], sorted[j] = sorted[j], sorted[i]
			}
		}
	}

	// Build ranges
	var ranges []string
	start := sorted[0]
	end := sorted[0]

	for i := 1; i < len(sorted); i++ {
		if sorted[i] == end+1 {
			// Contiguous, extend range
			end = sorted[i]
		} else {
			// Gap found, save current range and start new one
			if start == end {
				ranges = append(ranges, fmt.Sprintf("%d", start))
			} else {
				ranges = append(ranges, fmt.Sprintf("%d-%d", start, end))
			}
			start = sorted[i]
			end = sorted[i]
		}
	}

	// Add final range
	if start == end {
		ranges = append(ranges, fmt.Sprintf("%d", start))
	} else {
		ranges = append(ranges, fmt.Sprintf("%d-%d", start, end))
	}

	return LineRanges(strings.Join(ranges, ","))
}

func (lr LineRanges) String() string {
	return string(lr)
}

type CommitChange struct {
	File string `json:"file,omitempty"`
	// AST node path e.g. Type.method
	Node  string            `json:"node,omitempty"`
	Type  SourceChangeType  `json:"type,omitempty"`
	Scope Scopes            `json:"scopes,omitempty"`
	Tech  []ScopeTechnology `json:"tech,omitempty"`
	// Chars added
	Adds int `json:"adds,omitempty"`
	// Chars deleted
	Dels int `json:"dels,omitempty"`
	// Line numbers that were changed (additions only, in the new file) compressed into ranges
	// Format: "1-5,7-9,12" represents lines 1,2,3,4,5,7,8,9,12
	LinesChanged LineRanges `json:"lines_changed,omitempty"`
	// Kubernetes resource changes (if file contains Kubernetes resources)
	KubernetesChanges []kubernetes.KubernetesChange `json:"kubernetes_changes,omitempty"`
	// Severity of this change (calculated from rules engine)
	Severity Severity `json:"severity,omitempty"`
}

func (c CommitChange) Pretty() api.Text {
	// If Kubernetes changes are present, show them in condensed format instead of file-based format
	if len(c.KubernetesChanges) > 0 {
		var t api.Text
		for i, kc := range c.KubernetesChanges {
			if i > 0 {
				t = t.NewLine()
			}

			t = t.Append(kc.Pretty())
		}
		return t
	}

	// Fall back to file-based format if no Kubernetes changes
	t := clicky.Text("").Append(c.File, "font-mono").Space()

	if c.Adds > 0 {
		t = t.Append(fmt.Sprintf("+%d", c.Adds), "text-green-600")
	}
	if c.Dels > 0 {
		if c.Adds > 0 {
			t = t.Append("/", "text-muted")
		}
		t = t.Append(fmt.Sprintf("-%d", c.Dels), "text-red-600")
	}
	if len(c.Scope) > 0 {
		t = t.Append(" scope=", "text-muted").Append(c.Scope)
	}
	if len(c.Tech) > 0 {
		t = t.Append(" tech=", "text-muted")
		for i, v := range c.Tech {
			if i > 0 {
				t = t.Append(",", "text-muted")
			}
			t = t.Append(string(v))
		}
	}

	return t
}
